using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;
using System.Net;
using System.Net.Http.Headers;
using System.Reflection;
using System.Text;

namespace GraphQlClientGenerator;

public class GraphQlGenerator(GraphQlGeneratorConfiguration configuration = null)
{
    public const string AutoGeneratedLabel = "// <auto-generated> This file has been auto generated. </auto-generated>";

    public const string RequiredNamespaces =
        $"""
        using Microsoft.Extensions.DependencyInjection;
        using HotChocolate.ApolloFederation.Types;
        using HotChocolate.Execution.Configuration;
        """;

    private readonly GraphQlGeneratorConfiguration _configuration = configuration ?? new GraphQlGeneratorConfiguration();

    public static HttpClientHandler CreateDefaultHttpClientHandler() =>
        new() { AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate };

    private static HttpClient CreateHttpClient(HttpMessageHandler messageHandler = null) =>
        new(messageHandler ?? CreateDefaultHttpClientHandler())
        {
            DefaultRequestHeaders =
            {
                UserAgent = { ProductInfoHeaderValue.Parse($"GraphQlClientGenerator/{typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetName().Version}") }
            }
        };

    private static readonly JsonSerializerSettings SerializerSettings =
        new()
        {
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            Converters = { new StringEnumConverter() }
        };

    private static readonly GraphQlField TypeNameField =
        new()
        {
            Name = NamingHelper.MetadataFieldTypeName,
            Type = new GraphQlFieldType
            {
                Kind = GraphQlTypeKind.Scalar,
                Name = "String"
            }
        };

    private static HttpRequestMessage SetupHttpRequest(HttpMethod method, string url, string queryText, IEnumerable<KeyValuePair<string, string>> headers)
    {
        var request = new HttpRequestMessage(method, url);
        if (request.Method == HttpMethod.Get)
            request.RequestUri = new($"{request.RequestUri}?&query={queryText}");
        else
            request.Content = new StringContent(JsonConvert.SerializeObject(new { query = queryText }), Encoding.UTF8, "application/json");

        if (headers is not null)
            foreach (var kvp in headers)
                request.Headers.TryAddWithoutValidation(kvp.Key, kvp.Value);

        return request;
    }

    private static async Task<GraphQlSchema> QuerySchemaMetadata(HttpClient httpClient, HttpRequestMessage request)
    {
        using var response = await httpClient.SendAsync(request);
        var content =
            response.Content is null
                ? "(no content)"
                : await response.Content.ReadAsStringAsync();

        if (!response.IsSuccessStatusCode)
            throw new InvalidOperationException($"Status code: {(int)response.StatusCode} ({response.StatusCode}); content:{Environment.NewLine}{content}");

        return DeserializeGraphQlSchema(content);
    }

    public static async Task<GraphQlSchema> RetrieveSchema(
        HttpMethod method,
        string url,
        ICollection<KeyValuePair<string, string>> headers = null,
        HttpMessageHandler messageHandler = null,
        GraphQlWellKnownDirective? wellKnownDirectives = null)
    {
        using var httpClient = CreateHttpClient(messageHandler);

        if (wellKnownDirectives is null)
        {
            var schema = await QuerySchemaMetadata(httpClient, SetupHttpRequest(method, url, GraphQlIntrospection.QuerySupportedDirectives, headers));
            wellKnownDirectives = schema.Directives.Any(d => d.Name is "oneOf") ? GraphQlWellKnownDirective.OneOf : GraphQlWellKnownDirective.None;
        }

        using var request = SetupHttpRequest(method, url, GraphQlIntrospection.QuerySchemaMetadata(wellKnownDirectives.Value), headers);
        return await QuerySchemaMetadata(httpClient, request);
    }

    public static GraphQlSchema DeserializeGraphQlSchema(string content)
    {
        try
        {
            var schema =
                JsonConvert.DeserializeObject<GraphQlResult>(content, SerializerSettings)?.Data?.Schema
                ?? JsonConvert.DeserializeObject<GraphQlData>(content, SerializerSettings)?.Schema;

            return schema ?? throw new ArgumentException(NotGraphQlSchemaMessage(content));
        }
        catch (JsonReaderException exception)
        {
            throw new ArgumentException(NotGraphQlSchemaMessage(content), exception);
        }
    }

    private static string NotGraphQlSchemaMessage(string content) =>
        $"""
        not a GraphQL schema:
        {content}
        """;

    public string GenerateFullClientCSharpFile(GraphQlSchema schema, Action<string> logMessage = null)
    {
        var builder = new StringBuilder();
        using var writer = new StringWriter(builder);
        WriteFullClientCSharpFile(schema, writer, logMessage);
        return builder.ToString();
    }

    public void WriteFullClientCSharpFile(GraphQlSchema schema, TextWriter writer, Action<string> logMessage = null)
    {
        Generate(new SingleFileGenerationContext(schema, writer) { LogMessage = logMessage });
        writer.Flush();
    }

    public void Generate(GenerationContext context)
    {
        context.Initialize(_configuration);
        context.BeforeGeneration();

        GenerateEnums(context);

        GenerateInputObjects(context);

        GenerateDataClasses(context);

        GenerateExtensions(context);

        context.AfterGeneration();
    }

    private void GenerateExtensions(GenerationContext context)
    {
        var indentation = GetIndentation(context.IndentationSize);
        var writer = context.Writer;
        writer.Write(indentation);
        writer.WriteLine("public static class Extensions");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("    public static IRequestExecutorBuilder AddEnums(this IRequestExecutorBuilder builder)");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("        return builder");

        var enumTypes = OrderIfEnabled(context.Schema.Types.Where(t => t.Kind == GraphQlTypeKind.Enum && !t.IsBuiltIn())).ToList();

        enumTypes.ForEach(t =>
        {
            var enumName = context.GetFullyQualifiedNetTypeName(NamingHelper.ToPascalCase(t.Name), t.Kind);

            writer.WriteLine($".AddEnumType<{enumName}>()");
        });

        writer.WriteLine(";");
        writer.Write(indentation);
        writer.WriteLine("    }");
        writer.Write(indentation);



        var complexTypes = OrderIfEnabled(context.Schema.GetComplexTypes()).ToList();

        var unions = complexTypes.Where(t => t.Kind == GraphQlTypeKind.Union).ToList();
        writer.Write("    public static IRequestExecutorBuilder AddUnionTypes(this IRequestExecutorBuilder builder)");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("        return builder");
        unions.ForEach(t =>
        {
            var name = context.GetFullyQualifiedNetTypeName(NamingHelper.ToPascalCase(t.Name), t.Kind);
            writer.WriteLine($".AddUnionType<{name}>()");
        });
        writer.WriteLine(";");
        writer.Write(indentation);
        writer.WriteLine("    }");
        writer.Write(indentation);

        var interfaces = complexTypes.Where(t => t.Kind == GraphQlTypeKind.Interface).ToList();
        writer.Write("    public static IRequestExecutorBuilder AddInterfaceTypes(this IRequestExecutorBuilder builder)");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("        return builder");
        interfaces.ForEach(t =>
        {
            var name = context.GetFullyQualifiedNetTypeName(NamingHelper.ToPascalCase(t.Name), t.Kind);
            writer.WriteLine($".AddInterfaceType<{name}>(o => o.Name(\"{name.Substring(1)}\"))");
        });
        writer.WriteLine(";");
        writer.Write(indentation);
        writer.WriteLine("    }");
        writer.Write(indentation);
        writer.Write("    public static IRequestExecutorBuilder AddStandardTypes(this IRequestExecutorBuilder builder)");
        writer.Write(indentation);
        writer.WriteLine("{");
        writer.Write(indentation);
        writer.Write("        return builder");
        var standardTypes = complexTypes.Where(t => t.Kind != GraphQlTypeKind.Interface && t.Kind != GraphQlTypeKind.Union).ToList();

        standardTypes.ForEach(t =>
        {
            var name = context.GetCSharpClassName(t.Name);
            writer.WriteLine($".AddType<{name}>()");
        });

        writer.WriteLine(";");
        writer.Write(indentation);
        writer.WriteLine("    }");
        writer.Write(indentation);

        writer.WriteLine("}"); // End of Extensions class
    }

    private void GenerateGraphQlTypeNames(GenerationContext context)
    {
        context.BeforeGraphQlTypeNameGeneration();

        var indentation = GetIndentation(context.IndentationSize);
        var writer = context.Writer;
        writer.Write(indentation);
        writer.WriteLine("public static class GraphQlTypes");
        writer.Write(indentation);
        writer.WriteLine("{");

        var graphQlTypes = context.Schema.Types.Where(t => !t.IsBuiltIn()).OrderBy(t => t.Kind).ThenBy(t => t.Name).ToArray();
        GraphQlType precedingInputObjectType = null;
        foreach (var inputObjectType in graphQlTypes)
        {
            if (precedingInputObjectType is not null && inputObjectType.Kind != precedingInputObjectType.Kind)
                writer.WriteLine();

            writer.Write(indentation);
            writer.Write("    public const string ");
            writer.Write(NamingHelper.ToPascalCase(inputObjectType.Name));
            writer.Write(" = \"");
            writer.Write(inputObjectType.Name);
            writer.WriteLine("\";");

            precedingInputObjectType = inputObjectType;
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("    public static readonly IReadOnlyDictionary<global::System.Type, string> ReverseMapping =");
        writer.Write(indentation);
        writer.WriteLine("        new Dictionary<global::System.Type, string>");
        writer.Write(indentation);
        writer.WriteLine("        {");

        var netTypeKeys = new HashSet<string>();
        string typeMappingSeparator = null;

        foreach (var type in graphQlTypes.Where(t => t.Kind is GraphQlTypeKind.Object or GraphQlTypeKind.InputObject))
        {
            if (type.Kind is GraphQlTypeKind.InputObject)
            {
                var netType = context.GetFullyQualifiedNetTypeName(context.GetCSharpClassName(type.Name), type.Kind);
                WriteMappingEntry(netType, type.Name);
            }
            else
            {
                foreach (var member in type.Kind is GraphQlTypeKind.Object ? (IEnumerable<IGraphQlMember>)type.Fields : type.InputFields)
                {
                    var fieldType = member.Type.UnwrapIfNonNull();
                    if (fieldType.Kind is GraphQlTypeKind.List)
                    {
                        var itemType = UnwrapListItemType(fieldType, false, false, out _);
                        fieldType = itemType?.UnwrapIfNonNull();
                        if (fieldType is null)
                            continue;
                    }

                    if (fieldType.Kind != GraphQlTypeKind.Scalar)
                        continue;

                    var scalarFieldContext =
                        new ScalarFieldTypeProviderContext
                        {
                            Configuration = _configuration,
                            ComponentType = ClientComponentType.QueryBuilderParameter,
                            OwnerType = type,
                            FieldType = member.Type,
                            FieldName = member.Name
                        };

                    var netType = context.ResolveScalarNetType(scalarFieldContext).NetTypeName.TrimEnd('?');
                    if (netType.EndsWith("object") || netType.EndsWith("System.Object"))
                        continue;

                    WriteMappingEntry(netType, fieldType.Name);
                }
            }
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine("        };");
        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterGraphQlTypeNameGeneration();

        return;

        void WriteMappingEntry(string netType, string graphQlTypeName)
        {
            if (!netTypeKeys.Add(netType))
                return;

            if (typeMappingSeparator is not null)
                writer.WriteLine(typeMappingSeparator);

            writer.Write(indentation);
            writer.Write("            { typeof(");
            writer.Write(netType);
            writer.Write("), \"");
            writer.Write(graphQlTypeName);
            writer.Write("\" }");

            typeMappingSeparator = ",";
        }
    }

    private void GenerateEnums(GenerationContext context)
    {
        var enumTypes = OrderIfEnabled(context.Schema.Types.Where(t => t.Kind == GraphQlTypeKind.Enum && !t.IsBuiltIn())).ToList();
        if (!enumTypes.Any())
            return;

        context.BeforeEnumsGeneration();

        enumTypes.ForEach(t => GenerateEnum(context, t));

        context.AfterEnumsGeneration();
    }

    private IEnumerable<T> OrderIfEnabled<T>(IEnumerable<T> source) where T : GraphQlTypeBase =>
        _configuration.GenerationOrder is GenerationOrder.Alphabetical
            ? source.OrderBy(t => t.Name)
            : source;

    private static bool IsQueryBuilderGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.QueryBuilders);

    private static bool IsDataClassGenerationDisabled(GeneratedObjectType objectTypes) => !objectTypes.HasFlag(GeneratedObjectType.DataClasses);

    private void GenerateInputObjects(GenerationContext context)
    {
        if (IsDataClassGenerationDisabled(context.ObjectTypes))
            return;

        var inputObjectTypes = OrderIfEnabled(context.Schema.GetInputObjectTypes()).ToArray();
        if (!inputObjectTypes.Any())
            return;

        context.BeforeInputClassesGeneration();

        foreach (var inputObjectType in inputObjectTypes)
            GenerateFileMember(
                context,
                inputObjectType,
                [],
                c => GenerateInputDataClassBody(c, inputObjectType.InputFields, context));

        context.AfterInputClassesGeneration();
    }

    private void GenerateDataClasses(GenerationContext context)
    {
        if (IsDataClassGenerationDisabled(context.ObjectTypes))
            return;

        var complexTypes = OrderIfEnabled(context.Schema.GetComplexTypes()).ToDictionary(t => t.Name);
        if (!complexTypes.Any())
            return;

        context.BeforeDataClassesGeneration();

        foreach (var complexType in complexTypes.Values)
        {
            if (complexType.Kind is GraphQlTypeKind.Union)
            {
                GenerateFileMember(context, complexType, [], c => GenerateDataClassBody(c, [], context, true));
                continue;
            }

            var isInterface = complexType.Kind is GraphQlTypeKind.Interface;
            var interfacesToImplement = new HashSet<string>(context.TypeUnionMembership[complexType.Name].Select(n => context.GetFullyQualifiedNetTypeName(n, GraphQlTypeKind.Interface)));

            var fieldsToGenerate = context.GetFieldsToGenerate(complexType).Select(f => new FieldGenerationInfo(f, complexType, false)).ToList();

            //var implementsUnion = interfacesToImplement.Any();
            if (complexType.Interfaces?.Count > 0)
            {
                var namedFields = fieldsToGenerate.ToDictionary(f => f.Field.Name);
                if (isInterface)
                    fieldsToGenerate.Clear();

                foreach (var @interface in complexType.Interfaces)
                {
                    var csharpInterfaceName = context.GetCSharpClassName(@interface.Name, false);
                    var interfaceName = context.GetFullyQualifiedNetTypeName(csharpInterfaceName, GraphQlTypeKind.Interface);
                    interfacesToImplement.Add(interfaceName);

                    var interfaceType = complexTypes[@interface.Name];
                    foreach (var interfaceField in interfaceType.Fields.Where(context.FilterIfDeprecated))
                    {
                        if (!IsFieldOwner(complexTypes, interfaceType, interfaceField))
                            continue;

                        var interfaceFieldNetType = context.GetDataPropertyType(interfaceType, interfaceField).NetTypeName;
                        if (namedFields.TryGetValue(interfaceField.Name, out var nameField))
                        {
                            if (context.GetDataPropertyType(nameField.OwnerType, nameField.Field).NetTypeName != interfaceFieldNetType)
                            {
                                fieldsToGenerate.Add(
                                    isInterface
                                        ? nameField with { RequiresNew = true }
                                        : new(interfaceField, interfaceType, false));

                                fieldsToGenerate.Remove(nameField);
                            }
                        }
                        else
                        {
                            var missingField = new FieldGenerationInfo(interfaceField, complexType, false);
                            fieldsToGenerate.Add(missingField);
                            namedFields[interfaceField.Name] = missingField;
                        }
                    }
                }

            }

            if (isInterface || fieldsToGenerate.Any())
                GenerateFileMember(
                    context,
                    complexType,
                    interfacesToImplement,
                    objectContext => GenerateDataClassBody(objectContext, fieldsToGenerate, context, isInterface));
        }

        context.AfterDataClassesGeneration();
    }

    private static bool IsFieldOwner(Dictionary<string, GraphQlType> complexTypes, GraphQlType interfaceType, GraphQlField field)
    {
        if (interfaceType.Interfaces?.Count is null or 0)
            return true;

        foreach (var inheritedInterfaceReference in interfaceType.Interfaces)
        {
            var inheritedInterfaceType = complexTypes[inheritedInterfaceReference.Name];
            if (inheritedInterfaceType.Fields.Any(f => f.Name == field.Name && f.Type.Equals(field.Type)))
                return false;
        }

        return true;
    }

    private static string GetBackingFieldName(string graphQlFieldName, bool requiresRawName) =>
        requiresRawName
            ? $"_{graphQlFieldName}"
            : $"_{NamingHelper.LowerFirst(NamingHelper.ToPascalCase(graphQlFieldName))}";

    private void GenerateDataClassBody(ObjectGenerationContext objectContext, IReadOnlyList<FieldGenerationInfo> fieldsToGenerate, GenerationContext context, bool isInterfaceMember)
    {
        var type = objectContext.GraphQlType;
        var writer = context.Writer;
        var csharpNameLookup = fieldsToGenerate.Where(fi => fi.OwnerType == type).ToLookup(f => NamingHelper.ToPascalCase(f.Field.Name));
        var generateBackingFields =
            !isInterfaceMember &&
            _configuration.PropertyGeneration is PropertyGenerationOption.BackingField &&
            !_configuration.CSharpVersion.IsFieldKeywordSupported();

        if (generateBackingFields)
        {
            var indentation = GetIndentation(context.IndentationSize);

            foreach (var fieldInfo in fieldsToGenerate)
            {
                if (fieldInfo.OwnerType != type)
                    continue;

                var propertyName = NamingHelper.ToPascalCase(fieldInfo.Field.Name);
                var backingFieldName = GetBackingFieldName(fieldInfo.Field.Name, csharpNameLookup[propertyName].Count() > 1);

                writer.Write(indentation);
                writer.Write("    private ");
                writer.Write(context.GetDataPropertyType(type, fieldInfo.Field).NetTypeName);
                writer.Write(' ');
                writer.Write(backingFieldName);
                writer.WriteLine(";");
            }

            writer.WriteLine();
        }

        foreach (var fieldInfo in fieldsToGenerate)
        {
            var propertyName = NamingHelper.ToPascalCase(fieldInfo.Field.Name);
            var requiresRawName = csharpNameLookup[propertyName].Count() > 1;
            if (requiresRawName)
                propertyName = fieldInfo.Field.Name;

            GenerateDataProperty(
                objectContext,
                new DataPropertyContext
                {
                    Member = fieldInfo.Field,
                    OwnerType = fieldInfo.OwnerType,
                    PropertyName = propertyName,
                    RequiresNew = fieldInfo.RequiresNew,
                    IsDeprecated = fieldInfo.Field.IsDeprecated,
                    DeprecationReason = fieldInfo.Field.DeprecationReason,
                    DecorateWithJsonPropertyAttribute = true,
                    RequiresRawName = requiresRawName,
                    IsNullable = fieldInfo.Field.Type.Kind != GraphQlTypeKind.NonNull,
                },
                (_, propertyGenerationContext) => context.OnDataPropertyGeneration(propertyGenerationContext),
                context);
        }
    }

    private void GenerateInputDataClassBody(ObjectGenerationContext objectContext, IList<GraphQlArgument> members, GenerationContext context)
    {
        var writer = context.Writer;
        var indentation = GetIndentation(context.IndentationSize);
        var propertyContexts = new Dictionary<string, DataPropertyContext>();

        foreach (var member in members)
        {
            var fieldName = GetBackingFieldName(member.Name, false);
            var originalFieldName = fieldName;
            var collidingNameExtendingIndex = 1;
            while (propertyContexts.ContainsKey(fieldName))
                fieldName = $"{originalFieldName}{++collidingNameExtendingIndex}";

            var propertyName = NamingHelper.ToPascalCase(member.Name);
            if (collidingNameExtendingIndex > 1)
                propertyName = $"{propertyName}{collidingNameExtendingIndex}";

            propertyContexts.Add(
                fieldName,
                new DataPropertyContext
                {
                    Member = member,
                    OwnerType = objectContext.GraphQlType,
                    PropertyName = propertyName,
                    RequiresNew = false,
                    IsDeprecated = false,
                    DeprecationReason = null,
                    DecorateWithJsonPropertyAttribute = true,
                    RequiresRawName = false,
                    IsNullable = member.Type.Kind != GraphQlTypeKind.NonNull,
                });

        }

        foreach (var kvp in propertyContexts)
            GenerateDataProperty(
                objectContext,
                kvp.Value,
                (fieldTypeDescription, propertyGenerationContext) =>
                {
                    context.OnDataPropertyGeneration(propertyGenerationContext);

                    writer.WriteLine();
                },
                context);

        return;

        void WriteNewInputPropertyInfo(DataPropertyContext propertyContext, ScalarFieldTypeDescription fieldTypeDescription, string value)
        {
            writer.Write("new");
            writer.Write(_configuration.CSharpVersion.IsTargetTypedNewSupported() ? "()" : " InputPropertyInfo");
            writer.Write(" { Name = \"");
            writer.Write(propertyContext.Member.Name);
            writer.Write("\", Value = ");
            writer.Write(value);

            if (!String.IsNullOrEmpty(fieldTypeDescription.FormatMask))
            {
                writer.Write(", FormatMask = \"");
                writer.Write(fieldTypeDescription.FormatMask.Replace("\"", "\\\""));
                writer.Write("\"");
            }

            writer.Write(" };");
        }
    }

    private void GenerateFileMember(GenerationContext context, GraphQlType graphQlType, IReadOnlyCollection<string> interfaces, Action<ObjectGenerationContext> generateFileMemberBody)
    {
        var typeName = context.GetFullyQualifiedNetTypeName(context.GetCSharpClassName(graphQlType.Name), graphQlType.Kind);
        var gqlName = context.GetCSharpClassName(graphQlType.Name, false);
        CSharpHelper.ValidateClassName(typeName);

        var objectGenerationContext = new ObjectGenerationContext { GraphQlType = graphQlType, CSharpTypeName = typeName };

        context.BeforeDataClassGeneration(objectGenerationContext);

        var writer = context.Writer;

        GenerateCodeComments(writer, graphQlType.Description, context.IndentationSize);

        var indentation = GetIndentation(context.IndentationSize);

        if (graphQlType.Kind != GraphQlTypeKind.Interface && graphQlType.Kind != GraphQlTypeKind.Union)
        {
            writer.Write(indentation);
            writer.Write("[Shareable]");
            writer.WriteLine("");
        }

        if (gqlName != typeName)
        {
            writer.Write(indentation);
            writer.Write($"[GraphQLName(\"{gqlName}\")]");
            writer.WriteLine("");
        }

        writer.Write(indentation);
        writer.Write(GetMemberAccessibility());
        writer.Write(' ');

        if (_configuration.GeneratePartialClasses)
        {
            writer.Write("partial ");
        }
        writer.Write(graphQlType.Kind is GraphQlTypeKind.Interface or GraphQlTypeKind.Union ? "interface" : "class");
        writer.Write(' ');
        writer.Write(typeName);

        if (interfaces.Count > 0)
        {
            writer.Write(" : ");
            var separator = String.Empty;
            foreach (var @interface in interfaces)
            {
                writer.Write(separator);
                writer.Write(@interface);
                separator = ", ";
            }
        }

        writer.WriteLine();
        writer.Write(indentation);
        writer.WriteLine('{');

        context.OnDataClassConstructorGeneration(objectGenerationContext);

        generateFileMemberBody(objectGenerationContext);

        writer.Write(indentation);
        writer.WriteLine('}');

        context.AfterDataClassGeneration(objectGenerationContext);
    }

    private string AddQuestionMarkIfNullableReferencesEnabled(string dataTypeIdentifier) =>
        _configuration.EnableNullableReferences ? $"{dataTypeIdentifier}?" : dataTypeIdentifier;

    private string GetMemberAccessibility() =>
        _configuration.MemberAccessibility is MemberAccessibility.Internal ? "internal" : "public";

    private void GenerateDataProperty(
        ObjectGenerationContext objectContext,
        DataPropertyContext propertyContext,
        WriteDataClassPropertyBodyDelegate writeBody,
        GenerationContext context)
    {
        var ownerGraphQlType = objectContext.GraphQlType;
        var member = propertyContext.Member;
        var propertyTypeDescription = context.GetDataPropertyType(propertyContext.OwnerType, member);
        var isIdType = member.Type.Name == GraphQlTypeBase.GraphQlTypeScalarId;
        var isOwnerInputObjectInRichMode = ownerGraphQlType.Kind is GraphQlTypeKind.InputObject && _configuration.InputObjectMode is InputObjectMode.Rich;
        var propertyTypeName = propertyTypeDescription.NetTypeName;

        var propertyGenerationContext =
            new PropertyGenerationContext(
                objectContext,
                member,
                propertyTypeName,
                propertyContext.PropertyName,
                GetBackingFieldName(member.Name, propertyContext.RequiresRawName));

        context.BeforeDataPropertyGeneration(propertyGenerationContext);

        var writer = context.Writer;

        GenerateCodeComments(writer, member.Description, context.IndentationSize + 4);

        var indentation = GetIndentation(context.IndentationSize);

        if (propertyContext.IsDeprecated)
        {
            WriteObsoleteAttribute(writer, propertyContext.DeprecationReason, indentation);
        }

        if (!propertyContext.IsNullable)
        {
            WriteNonNullAttribute(writer, indentation);
        }

        if (isIdType)
        {
            WriteIdAttribute(writer, indentation);
        }

        var decorateWithJsonPropertyAttribute = propertyContext.DecorateWithJsonPropertyAttribute;
        if (decorateWithJsonPropertyAttribute)
        {
            decorateWithJsonPropertyAttribute =
                _configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.Always ||
                !String.Equals(
                    member.Name,
                    propertyContext.PropertyName.TrimStart('@'),
                    _configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.CaseInsensitive ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);

            if (_configuration.JsonPropertyGeneration is JsonPropertyGenerationOption.Never or JsonPropertyGenerationOption.UseDefaultAlias)
                decorateWithJsonPropertyAttribute = false;
        }

        var isInterface = ownerGraphQlType.Kind is GraphQlTypeKind.Interface;

        writer.Write(indentation);
        writer.Write("    ");

        if (propertyContext.RequiresNew)
            writer.Write("new ");

        writeBody(propertyTypeDescription, propertyGenerationContext);

        context.AfterDataPropertyGeneration(propertyGenerationContext);
    }

    private void WriteIdAttribute(TextWriter writer, string indentation)
    {
        writer.Write(indentation);
        writer.Write("    [ID]");
        writer.WriteLine("");
    }

    internal static InvalidOperationException ListItemTypeResolutionFailedException(string typeName, string fieldName) =>
            FieldTypeResolutionFailedException(typeName, fieldName, "list item type was not resolved; nested collections too deep");

    private static InvalidOperationException FieldTypeResolutionFailedException(string typeName, string fieldName, string reason) =>
        new($"field type resolution failed - type: {typeName}; field: {fieldName}{(reason is null ? null : $"; reason: {reason}")}");


    private static void WriteObsoleteAttribute(TextWriter writer, string deprecationReason, string indentation)
    {
        writer.Write(indentation);
        writer.Write("    [GraphQLDeprecated");

        if (!String.IsNullOrWhiteSpace(deprecationReason))
        {
            writer.Write("(@\"");
            writer.Write(deprecationReason.Replace("\"", "\"\""));
            writer.Write("\")");
        }

        writer.WriteLine("]");
    }

    private static void WriteNonNullAttribute(TextWriter writer, string indentation)
    {
        writer.Write(indentation);
        writer.Write("    [GraphQLNonNullType]");
        writer.WriteLine("");
    }

    private IReadOnlyList<QueryBuilderParameterDefinition> ResolveParameterDefinitions(GenerationContext context, GraphQlTypeBase type, IEnumerable<GraphQlArgument> graphQlArguments)
    {
        if (graphQlArguments is null)
            return [];

        var parameterDefinitions = new List<QueryBuilderParameterDefinition>();
        var collidingNames = new Dictionary<string, int>();
        foreach (var argument in graphQlArguments.Where(a => IsCompatibleArgument(a.Type)))
        {
            var netParameterName = CSharpHelper.EnsureCSharpQuoting(NamingHelper.LowerFirst(NamingHelper.ToPascalCase(argument.Name)));
            collidingNames[netParameterName] = collidingNames.TryGetValue(netParameterName, out var extendingIndex) ? extendingIndex + 1 : 1;

            if (extendingIndex > 0)
                netParameterName = $"{netParameterName}{++extendingIndex}";

            parameterDefinitions.Add(BuildMethodParameterDefinition(context, type, argument, netParameterName));
        }

        return parameterDefinitions;

        static bool IsCompatibleArgument(GraphQlFieldType argumentType)
        {
            argumentType = argumentType.UnwrapIfNonNull();
            return
                argumentType.Kind switch
                {
                    GraphQlTypeKind.Scalar => true,
                    GraphQlTypeKind.Enum => true,
                    GraphQlTypeKind.InputObject => true,
                    GraphQlTypeKind.List => IsCompatibleArgument(argumentType.OfType),
                    _ => false
                };
        }
    }

    internal static GraphQlFieldType UnwrapIfNotNullOrList(GraphQlFieldType type)
    {
        var fieldType = type.UnwrapIfNonNull();
        if (fieldType.Kind is GraphQlTypeKind.List)
            fieldType = UnwrapListItemType(fieldType, false, false, out _);

        return fieldType.UnwrapIfNonNull();
    }

    internal static GraphQlFieldType UnwrapListItemType(GraphQlFieldType type, bool nullableReferencesEnabled, bool isCovarianceRequired, out string netCollectionOpenType)
    {
        var levels = 0;

        var nullableSymbols = new List<string> { String.Empty };

        while (true)
        {
            levels++;

            var unwrappedType = type.OfType?.UnwrapIfNonNull();
            if (unwrappedType is null)
            {
                netCollectionOpenType = null;
                return null;
            }

            if (unwrappedType.Kind != GraphQlTypeKind.List)
            {
                type = type.OfType;
                break;
            }

            nullableSymbols.Add(type.OfType.Kind == GraphQlTypeKind.NonNull ? String.Empty : nullableReferencesEnabled ? "?" : String.Empty);
            type = unwrappedType;
        }

        nullableSymbols.Reverse();

        netCollectionOpenType =
            levels == 1
                ? isCovarianceRequired ? "IEnumerable<{0}>" : "ICollection<{0}>"
                : String.Concat(Enumerable.Repeat(isCovarianceRequired ? "IEnumerable<" : "ICollection<", levels).Append("{0}").Concat(nullableSymbols.Select(s => $">{s}")));

        return type;
    }

    private QueryBuilderParameterDefinition BuildMethodParameterDefinition(GenerationContext context, GraphQlTypeBase ownerType, GraphQlArgument argument, string netParameterName)
    {
        var argumentType = argument.Type;
        var isArgumentNotNull = argumentType.Kind is GraphQlTypeKind.NonNull;
        var isTypeNotNull = isArgumentNotNull;
        var unwrappedType = argumentType.UnwrapIfNonNull();
        var isCollection = unwrappedType.Kind is GraphQlTypeKind.List;
        if (isCollection)
        {
            isTypeNotNull = unwrappedType.OfType.Kind is GraphQlTypeKind.NonNull;
            argumentType = unwrappedType.OfType;
            unwrappedType = argumentType.UnwrapIfNonNull();
        }

        var scalarFieldContext =
            new ScalarFieldTypeProviderContext
            {
                Configuration = _configuration,
                ComponentType = ClientComponentType.QueryBuilderParameter,
                OwnerType = ownerType,
                FieldType = argumentType,
                FieldName = argument.Name
            };

        var argumentTypeDescription =
            unwrappedType.Kind is GraphQlTypeKind.Enum
                ? ScalarFieldTypeDescription.FromNetTypeName($"{context.GetFullyQualifiedNetTypeName(NamingHelper.ToPascalCase(unwrappedType.Name), unwrappedType.Kind)}{(isTypeNotNull ? null : "?")}")
                : context.ResolveScalarNetType(scalarFieldContext);

        var argumentNetType = argumentTypeDescription.NetTypeName;

        var isInputObject = unwrappedType.Kind == GraphQlTypeKind.InputObject;
        if (isInputObject)
        {
            argumentNetType = context.GetCSharpClassName(unwrappedType.Name);
            argumentNetType = context.GetFullyQualifiedNetTypeName(argumentNetType, unwrappedType.Kind);

            if (!isTypeNotNull)
                argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);
        }

        argumentNetType = isCollection ? $"IEnumerable<{argumentNetType}>" : $"{argumentNetType}";

        if (!isArgumentNotNull)
            argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);

        var argumentDefinition = $"{argumentNetType} {netParameterName}";
        if (!isArgumentNotNull)
            argumentDefinition = $"{argumentDefinition} = null";

        return
            new QueryBuilderParameterDefinition
            {
                Argument = argument,
                IsNullable = !isArgumentNotNull,
                NetParameterName = netParameterName,
                NetParameterDefinitionClause = argumentDefinition,
                FormatMask = argumentTypeDescription.FormatMask
            };
    }

    private void GenerateEnum(GenerationContext context, GraphQlType graphQlType)
    {
        var enumName = context.GetFullyQualifiedNetTypeName(NamingHelper.ToPascalCase(graphQlType.Name), graphQlType.Kind);

        var objectGenerationContext =
            new ObjectGenerationContext
            {
                GraphQlType = graphQlType,
                CSharpTypeName = enumName
            };

        context.BeforeEnumGeneration(objectGenerationContext);

        var writer = context.Writer;

        GenerateCodeComments(writer, graphQlType.Description, context.IndentationSize);
        var indentation = GetIndentation(context.IndentationSize);
        writer.Write(indentation);
        writer.Write("public enum ");
        writer.WriteLine(enumName);
        writer.Write(indentation);
        writer.WriteLine("{");

        var useCSharpNaming = _configuration.EnumValueNaming == EnumValueNamingOption.CSharp;
        var enumFieldsToGenerate = graphQlType.EnumValues.Where(context.FilterIfDeprecated).ToArray();
        var byIdentifierGroupedFieldsToGenerate =
            enumFieldsToGenerate
                .GroupBy(v => useCSharpNaming ? NamingHelper.ToCSharpEnumName(v.Name) : CSharpHelper.EnsureCSharpQuoting(v.Name))
                .ToArray();

        var valueCounter = 0;
        foreach (var nameValues in byIdentifierGroupedFieldsToGenerate)
        {
            foreach (var enumValue in nameValues)
            {
                GenerateCodeComments(writer, enumValue.Description, context.IndentationSize + 4);

                if (enumValue.IsDeprecated)
                    WriteObsoleteAttribute(writer, enumValue.DeprecationReason, indentation);

                writer.Write(indentation);
                writer.Write("    ");

                var enumIdentifier = nameValues.Count() == 1 ? nameValues.Key : enumValue.Name;
                if (useCSharpNaming && enumIdentifier != enumValue.Name)
                {
                    writer.Write("[GraphQLName(\"");
                    writer.Write(enumValue.Name);
                    writer.Write("\")] ");
                }

                writer.Write(enumIdentifier);

                if (++valueCounter < enumFieldsToGenerate.Length)
                    writer.Write(",");

                writer.WriteLine();
            }
        }

        writer.Write(indentation);
        writer.WriteLine("}");

        context.AfterEnumGeneration(objectGenerationContext);
    }

    private static readonly HashSet<GraphQlDirectiveLocation> SupportedDirectiveLocations =
    [
        GraphQlDirectiveLocation.Object,
        GraphQlDirectiveLocation.Field,
        GraphQlDirectiveLocation.Query,
        GraphQlDirectiveLocation.Mutation,
        GraphQlDirectiveLocation.Subscription
    ];

    private void GenerateCodeComments(TextWriter writer, string description, int indentationSize)
    {
        if (String.IsNullOrWhiteSpace(description))
            return;

        var indentation = GetIndentation(indentationSize);

        if (_configuration.CodeDocumentationType.HasFlag(CodeDocumentationType.XmlSummary))
        {
            writer.Write(indentation);
            writer.WriteLine("/// <summary>");

            foreach (var line in description.Split('\n').Select(l => l.Trim().EscapeXmlElementText()))
            {
                writer.Write(indentation);
                writer.Write("/// ");
                writer.WriteLine(line);
            }

            writer.Write(indentation);
            writer.WriteLine("/// </summary>");
        }

        if (_configuration.CodeDocumentationType.HasFlag(CodeDocumentationType.DescriptionAttribute))
        {
            writer.Write(indentation);
            writer.Write("[GraphQLDescription(@\"");
            writer.Write(description.Replace("\"", "\"\""));
            writer.WriteLine("\")]");
        }
    }

    public static string GetIndentation(int size) => new(' ', size);

    private record struct QueryBuilderParameterDefinition(
        GraphQlArgument Argument,
        bool IsNullable,
        string NetParameterName,
        string NetParameterDefinitionClause,
        string FormatMask);

    private record struct DataPropertyContext(
        IGraphQlMember Member,
        GraphQlTypeBase OwnerType,
        string PropertyName,
        bool RequiresNew,
        bool IsDeprecated,
        string DeprecationReason,
        bool DecorateWithJsonPropertyAttribute,
        bool RequiresRawName,
        bool IsNullable);

    private record struct FieldGenerationInfo(GraphQlField Field, GraphQlType OwnerType, bool RequiresNew);

    private delegate void WriteDataClassPropertyBodyDelegate(ScalarFieldTypeDescription netType, PropertyGenerationContext propertyGenerationContext);
}